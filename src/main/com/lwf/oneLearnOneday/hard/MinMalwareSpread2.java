package com.lwf.oneLearnOneday.hard;

import java.util.*;

/**
 * 928. 尽量减少恶意软件的传播 II
 *
 * @author: liuwenfei
 * @date: 2024/4/17-9:03
 */
public class MinMalwareSpread2 {
    /**
     * 1.可以移除一个点和连接关系
     * 1.如果该点只有一个感染点，则移除相当于移除整个联通集
     * 2.如果是有多个感染点，则感染点在环上，移除只减小1，不在环上，则可以影响的是只经过这个点的联通集
     * 3.正向思路的连通性不好判断，正难则反！！！我们可以反过来，假设所有的感染点都不联通，我们可以使用剩余的构建联通集
     * 然后遍历所有感染点，对于只有一个感染点连通的集合就是该点的可见小范围，这样我们就能够获取到每个点收益
     */
    class Solution {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            int n = graph.length;
            Arrays.sort(initial);
            List<Integer> ps = new ArrayList<>();
            for (int i : initial) {
                ps.add(i);
            }
            //1.构建不包含感染源的连通图
            UnionFind unionFind = new UnionFind(n);
            for (int i = 0; i < graph.length; i++) {
                if (ps.contains(i)) {
                    continue;
                }
                for (int j = i + 1; j < graph[i].length; j++) {
                    if (ps.contains(j)) {
                        continue;
                    }
                    if (graph[i][j] == 1) {
                        unionFind.union(i, j);
                    }
                }
            }
            //获取每个联通集与污染点相连接的数量
            Set<Integer>[] hasInits = new Set[n];
            for (int i = 0; i < hasInits.length; i++) {
                hasInits[i] = new HashSet<>();
            }
            for (int i : initial) {
                for (int j = 0; j < graph[i].length; j++) {
                    //需要排除自身，感染点！！！
                    if (i!=j&& !ps.contains(j)&& graph[i][j] == 1) {
                        int parent = unionFind.find(j);
                        hasInits[parent].add(i);
                    }
                }
            }
            //获取每个点的单点联通集size
            int max = -1, ans = -1;
            int[] inits = new int[n];
            for (int i = 0; i < hasInits.length; i++) {
                if (hasInits[i].size() == 1) {
                    int size = unionFind.size(i);
                    Integer init = hasInits[i].iterator().next();
                    inits[init] += size;
                    if (inits[init]>max){
                        ans=init;
                        max=inits[init];
                    }else if (inits[init]==max){
                        ans=Math.min(ans,init);
                    }
                }
            }
            return ans == -1 ? initial[0] : ans;
        }

        public class UnionFind {
            int[] parents;
            int[] size;

            UnionFind(int n) {
                parents = new int[n];
                for (int i = 0; i < parents.length; i++) {
                    parents[i] = i;
                }
                size = new int[n];
                Arrays.fill(size, 1);
            }

            public int find(int x) {
                if (parents[x] != x) {
                    parents[x] = find(parents[x]);
                }
                return parents[x];
            }

            public void union(int i, int j) {
                int i1 = find(i);
                int j1 = find(j);
                if (i1 == j1) {
                    return;
                }
                if (i1 > j1) {
                    parents[i1] = j1;
                    size[j1] += size[i1];
                } else {
                    parents[j1] = i1;
                    size[i1] += size[j1];
                }
            }

            public int size(int x) {
                return size[x];
            }
        }
    }
}
