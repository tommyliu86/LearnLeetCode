package com.lwf.oneLearnOneday.hard;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 924. 尽量减少恶意软件的传播
 *
 * @author: liuwenfei
 * @date: 2024/4/16-9:18
 */
public class MinMalwareSpread {
    /**
     * graph 表示链接，通过深度优先遍历，找到每个联通集合，就是感染的范围，
     * 1.遍历后，获取单独的节点可以感染的数量，如果存在这样的集合，其中的最大值就是
     * 2.如果不存在单独节点，那么剩余的都是联通集，这样移除一个节点是没有影响的，那么直接返回最小的点就可以了
     */
    class Solution {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            Arrays.sort(initial);
            int n = graph.length;
            UnionFind unionFind = new UnionFind(n);
            for (int i = 0; i < graph.length; i++) {
                for (int j = i + 1; j < graph[i].length; j++) {
                    if (graph[i][j] == 1) {
                        unionFind.union(i, j);
                    }
                }
            }
            //每个parent下有几个污染点
            int[] mm = new int[n];

            for (int i = 0; i < initial.length; i++) {
                mm[unionFind.find(initial[i])]++;
            }
            int ans = -1, max = -1;
            for (int i = 0; i < initial.length; i++) {
                int i1 = initial[i];
                //只有一个污染点，则更新
                if (mm[unionFind.find(i1)] == 1) {
                    int size = unionFind.size(unionFind.find(i1));
                    if (size > max) {
                        ans = i1;
                        max = size;
                    }
                }
            }
            return ans == -1 ? initial[0] : ans;
        }

        public class UnionFind {
            int[] points;
            int[] size;

            UnionFind(int n) {
                points = new int[n];
                for (int i = 0; i < points.length; i++) {
                    points[i] = i;
                }
                size = new int[n];
                Arrays.fill(size, 1);
            }

            public int size(int i) {
                return size[i];
            }

            public void union(int i, int j) {
                int parentI = find(i);
                int parentJ = find(j);
                if (parentI == parentJ) {
                    return;
                }
                if (parentI > parentJ) {
                    points[parentI] = parentJ;
                    size[parentJ] += size[parentI];
                } else {
                    points[parentJ] = parentI;
                    size[parentI] += size[parentJ];
                }
            }

            //查找时进行归并
            public int find(int x) {
                if (points[x] != x) {
                    points[x] = find(points[x]);
                }
                return points[x];
            }
        }
    }
}
